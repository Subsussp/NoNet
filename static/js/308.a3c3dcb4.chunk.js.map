{"version":3,"file":"static/js/308.a3c3dcb4.chunk.js","mappings":"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","sources":["../node_modules/lenis/packages/core/src/maths.ts","../node_modules/lenis/packages/core/src/animate.ts","../node_modules/lenis/packages/core/src/dimensions.ts","../node_modules/lenis/packages/core/src/debounce.ts","../node_modules/lenis/packages/core/src/emitter.ts","../node_modules/lenis/packages/core/src/virtual-scroll.ts","../node_modules/lenis/packages/core/src/lenis.ts","../node_modules/lenis/package.json","../node_modules/locomotive-scroll/core/IO.ts","../node_modules/locomotive-scroll/utils/maths.ts","../node_modules/locomotive-scroll/core/ScrollElement.ts","../node_modules/locomotive-scroll/core/Core.ts","../node_modules/locomotive-scroll/index.ts"],"sourcesContent":["/**\n * Clamp a value between a minimum and maximum value\n *\n * @param min Minimum value\n * @param input Value to clamp\n * @param max Maximum value\n * @returns Clamped value\n */\nexport function clamp(min: number, input: number, max: number) {\n  return Math.max(min, Math.min(input, max))\n}\n\n/**\n * Truncate a floating-point number to a specified number of decimal places\n *\n * @param value Value to truncate\n * @param decimals Number of decimal places to truncate to\n * @returns Truncated value\n */\nexport function truncate(value: number, decimals = 0) {\n  return parseFloat(value.toFixed(decimals))\n}\n\n/**\n *  Linearly interpolate between two values using an amount (0 <= t <= 1)\n *\n * @param x First value\n * @param y Second value\n * @param t Amount to interpolate (0 <= t <= 1)\n * @returns Interpolated value\n */\nexport function lerp(x: number, y: number, t: number) {\n  return (1 - t) * x + t * y\n}\n\n/**\n * Damp a value over time using a damping factor\n * {@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}\n *\n * @param x Initial value\n * @param y Target value\n * @param lambda Damping factor\n * @param dt Time elapsed since the last update\n * @returns Damped value\n */\nexport function damp(x: number, y: number, lambda: number, deltaTime: number) {\n  return lerp(x, y, 1 - Math.exp(-lambda * deltaTime))\n}\n\n/**\n * Calculate the modulo of the dividend and divisor while keeping the result within the same sign as the divisor\n * {@link https://anguscroll.com/just/just-modulo}\n *\n * @param n Dividend\n * @param d Divisor\n * @returns Modulo\n */\nexport function modulo(n: number, d: number) {\n  return ((n % d) + d) % d\n}\n","import { clamp, damp } from './maths'\r\nimport type { EasingFunction, FromToOptions, OnUpdateCallback } from './types'\r\n\r\n/**\r\n * Animate class to handle value animations with lerping or easing\r\n *\r\n * @example\r\n * const animate = new Animate()\r\n * animate.fromTo(0, 100, { duration: 1, easing: (t) => t })\r\n * animate.advance(0.5) // 50\r\n */\r\nexport class Animate {\r\n  isRunning = false\r\n  value = 0\r\n  from = 0\r\n  to = 0\r\n  currentTime = 0\r\n\r\n  // These are instanciated in the fromTo method\r\n  lerp?: number\r\n  duration?: number\r\n  easing?: EasingFunction\r\n  onUpdate?: OnUpdateCallback\r\n\r\n  /**\r\n   * Advance the animation by the given delta time\r\n   *\r\n   * @param deltaTime - The time in seconds to advance the animation\r\n   */\r\n  advance(deltaTime: number) {\r\n    if (!this.isRunning) return\r\n\r\n    let completed = false\r\n\r\n    if (this.duration && this.easing) {\r\n      this.currentTime += deltaTime\r\n      const linearProgress = clamp(0, this.currentTime / this.duration, 1)\r\n\r\n      completed = linearProgress >= 1\r\n      const easedProgress = completed ? 1 : this.easing(linearProgress)\r\n      this.value = this.from + (this.to - this.from) * easedProgress\r\n    } else if (this.lerp) {\r\n      this.value = damp(this.value, this.to, this.lerp * 60, deltaTime)\r\n      if (Math.round(this.value) === this.to) {\r\n        this.value = this.to\r\n        completed = true\r\n      }\r\n    } else {\r\n      // If no easing or lerp, just jump to the end value\r\n      this.value = this.to\r\n      completed = true\r\n    }\r\n\r\n    if (completed) {\r\n      this.stop()\r\n    }\r\n\r\n    // Call the onUpdate callback with the current value and completed status\r\n    this.onUpdate?.(this.value, completed)\r\n  }\r\n\r\n  /** Stop the animation */\r\n  stop() {\r\n    this.isRunning = false\r\n  }\r\n\r\n  /**\r\n   * Set up the animation from a starting value to an ending value\r\n   * with optional parameters for lerping, duration, easing, and onUpdate callback\r\n   *\r\n   * @param from - The starting value\r\n   * @param to - The ending value\r\n   * @param options - Options for the animation\r\n   */\r\n  fromTo(\r\n    from: number,\r\n    to: number,\r\n    { lerp, duration, easing, onStart, onUpdate }: FromToOptions\r\n  ) {\r\n    this.from = this.value = from\r\n    this.to = to\r\n    this.lerp = lerp\r\n    this.duration = duration\r\n    this.easing = easing\r\n    this.currentTime = 0\r\n    this.isRunning = true\r\n\r\n    onStart?.()\r\n    this.onUpdate = onUpdate\r\n  }\r\n}\r\n","import { debounce } from './debounce'\n\n/**\n * Dimensions class to handle the size of the content and wrapper\n *\n * @example\n * const dimensions = new Dimensions(wrapper, content)\n * dimensions.on('resize', (e) => {\n *   console.log(e.width, e.height)\n * })\n */\nexport class Dimensions {\n  width = 0\n  height = 0\n  scrollHeight = 0\n  scrollWidth = 0\n\n  // These are instanciated in the constructor as they need information from the options\n  private debouncedResize?: (...args: unknown[]) => void\n  private wrapperResizeObserver?: ResizeObserver\n  private contentResizeObserver?: ResizeObserver\n\n  constructor(\n    private wrapper: HTMLElement | Window | Element,\n    private content: HTMLElement | Element,\n    { autoResize = true, debounce: debounceValue = 250 } = {}\n  ) {\n    if (autoResize) {\n      this.debouncedResize = debounce(this.resize, debounceValue)\n\n      if (this.wrapper instanceof Window) {\n        window.addEventListener('resize', this.debouncedResize, false)\n      } else {\n        this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize)\n        this.wrapperResizeObserver.observe(this.wrapper)\n      }\n\n      this.contentResizeObserver = new ResizeObserver(this.debouncedResize)\n      this.contentResizeObserver.observe(this.content)\n    }\n\n    this.resize()\n  }\n\n  destroy() {\n    this.wrapperResizeObserver?.disconnect()\n    this.contentResizeObserver?.disconnect()\n\n    if (this.wrapper === window && this.debouncedResize) {\n      window.removeEventListener('resize', this.debouncedResize, false)\n    }\n  }\n\n  resize = () => {\n    this.onWrapperResize()\n    this.onContentResize()\n  }\n\n  onWrapperResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.width = window.innerWidth\n      this.height = window.innerHeight\n    } else {\n      this.width = this.wrapper.clientWidth\n      this.height = this.wrapper.clientHeight\n    }\n  }\n\n  onContentResize = () => {\n    if (this.wrapper instanceof Window) {\n      this.scrollHeight = this.content.scrollHeight\n      this.scrollWidth = this.content.scrollWidth\n    } else {\n      this.scrollHeight = this.wrapper.scrollHeight\n      this.scrollWidth = this.wrapper.scrollWidth\n    }\n  }\n\n  get limit() {\n    return {\n      x: this.scrollWidth - this.width,\n      y: this.scrollHeight - this.height,\n    }\n  }\n}\n","export function debounce<CB extends (...args: any[]) => void>(\n  callback: CB,\n  delay: number\n) {\n  let timer: number | undefined\n  return function <T>(this: T, ...args: Parameters<typeof callback>) {\n    let context = this\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      timer = undefined\n      callback.apply(context, args)\n    }, delay)\n  }\n}\n","/**\n * Emitter class to handle events\n * @example\n * const emitter = new Emitter()\n * emitter.on('event', (data) => {\n *   console.log(data)\n * })\n * emitter.emit('event', 'data')\n */\nexport class Emitter {\n  private events: Record<\n    string,\n    Array<(...args: unknown[]) => void> | undefined\n  > = {}\n\n  /**\n   * Emit an event with the given data\n   * @param event Event name\n   * @param args Data to pass to the event handlers\n   */\n  emit(event: string, ...args: unknown[]) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i]?.(...args)\n    }\n  }\n\n  /**\n   * Add a callback to the event\n   * @param event Event name\n   * @param cb Callback function\n   * @returns Unsubscribe function\n   */\n  on<CB extends (...args: any[]) => void>(event: string, cb: CB) {\n    // Add the callback to the event's callback list, or create a new list with the callback\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n\n    // Return an unsubscribe function\n    return () => {\n      this.events[event] = this.events[event]?.filter((i) => cb !== i)\n    }\n  }\n\n  /**\n   * Remove a callback from the event\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off<CB extends (...args: any[]) => void>(event: string, callback: CB) {\n    this.events[event] = this.events[event]?.filter((i) => callback !== i)\n  }\n\n  /**\n   * Remove all event listeners and clean up\n   */\n  destroy() {\n    this.events = {}\n  }\n}\n","import { Emitter } from './emitter'\r\nimport type { VirtualScrollCallback } from './types'\r\n\r\nconst LINE_HEIGHT = 100 / 6\r\nconst listenerOptions: AddEventListenerOptions = { passive: false }\r\n\r\nexport class VirtualScroll {\r\n  touchStart = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  lastDelta = {\r\n    x: 0,\r\n    y: 0,\r\n  }\r\n  window = {\r\n    width: 0,\r\n    height: 0,\r\n  }\r\n  private emitter = new Emitter()\r\n\r\n  constructor(\r\n    private element: HTMLElement,\r\n    private options = { wheelMultiplier: 1, touchMultiplier: 1 }\r\n  ) {\r\n    window.addEventListener('resize', this.onWindowResize, false)\r\n    this.onWindowResize()\r\n\r\n    this.element.addEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.addEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.addEventListener('touchend', this.onTouchEnd, listenerOptions)\r\n  }\r\n\r\n  /**\r\n   * Add an event listener for the given event and callback\r\n   *\r\n   * @param event Event name\r\n   * @param callback Callback function\r\n   */\r\n  on(event: string, callback: VirtualScrollCallback) {\r\n    return this.emitter.on(event, callback)\r\n  }\r\n\r\n  /** Remove all event listeners and clean up */\r\n  destroy() {\r\n    this.emitter.destroy()\r\n\r\n    window.removeEventListener('resize', this.onWindowResize, false)\r\n\r\n    this.element.removeEventListener('wheel', this.onWheel, listenerOptions)\r\n    this.element.removeEventListener(\r\n      'touchstart',\r\n      this.onTouchStart,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchmove',\r\n      this.onTouchMove,\r\n      listenerOptions\r\n    )\r\n    this.element.removeEventListener(\r\n      'touchend',\r\n      this.onTouchEnd,\r\n      listenerOptions\r\n    )\r\n  }\r\n\r\n  /**\r\n   * Event handler for 'touchstart' event\r\n   *\r\n   * @param event Touch event\r\n   */\r\n  onTouchStart = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: 0,\r\n      y: 0,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX: 0,\r\n      deltaY: 0,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'touchmove' event */\r\n  onTouchMove = (event: TouchEvent) => {\r\n    // @ts-expect-error - event.targetTouches is not defined\r\n    const { clientX, clientY } = event.targetTouches\r\n      ? event.targetTouches[0]\r\n      : event\r\n\r\n    const deltaX = -(clientX - this.touchStart.x) * this.options.touchMultiplier\r\n    const deltaY = -(clientY - this.touchStart.y) * this.options.touchMultiplier\r\n\r\n    this.touchStart.x = clientX\r\n    this.touchStart.y = clientY\r\n\r\n    this.lastDelta = {\r\n      x: deltaX,\r\n      y: deltaY,\r\n    }\r\n\r\n    this.emitter.emit('scroll', {\r\n      deltaX,\r\n      deltaY,\r\n      event,\r\n    })\r\n  }\r\n\r\n  onTouchEnd = (event: TouchEvent) => {\r\n    this.emitter.emit('scroll', {\r\n      deltaX: this.lastDelta.x,\r\n      deltaY: this.lastDelta.y,\r\n      event,\r\n    })\r\n  }\r\n\r\n  /** Event handler for 'wheel' event */\r\n  onWheel = (event: WheelEvent) => {\r\n    let { deltaX, deltaY, deltaMode } = event\r\n\r\n    const multiplierX =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.width : 1\r\n    const multiplierY =\r\n      deltaMode === 1 ? LINE_HEIGHT : deltaMode === 2 ? this.window.height : 1\r\n\r\n    deltaX *= multiplierX\r\n    deltaY *= multiplierY\r\n\r\n    deltaX *= this.options.wheelMultiplier\r\n    deltaY *= this.options.wheelMultiplier\r\n\r\n    this.emitter.emit('scroll', { deltaX, deltaY, event })\r\n  }\r\n\r\n  onWindowResize = () => {\r\n    this.window = {\r\n      width: window.innerWidth,\r\n      height: window.innerHeight,\r\n    }\r\n  }\r\n}\r\n","import { version } from '../../../package.json'\nimport { Animate } from './animate'\nimport { Dimensions } from './dimensions'\nimport { Emitter } from './emitter'\nimport { clamp, modulo } from './maths'\nimport type {\n  LenisEvent,\n  LenisOptions,\n  ScrollCallback,\n  Scrolling,\n  ScrollToOptions,\n  UserData,\n  VirtualScrollCallback,\n  VirtualScrollData,\n} from './types'\nimport { VirtualScroll } from './virtual-scroll'\n\n// Technical explanation\n// - listen to 'wheel' events\n// - prevent 'wheel' event to prevent scroll\n// - normalize wheel delta\n// - add delta to targetScroll\n// - animate scroll to targetScroll (smooth context)\n// - if animation is not running, listen to 'scroll' events (native context)\n\ntype OptionalPick<T, F extends keyof T> = Omit<T, F> & Partial<Pick<T, F>>\n\nconst defaultEasing = (t: number) => Math.min(1, 1.001 - Math.pow(2, -10 * t))\n\nexport class Lenis {\n  private _isScrolling: Scrolling = false // true when scroll is animating\n  private _isStopped = false // true if user should not be able to scroll - enable/disable programmatically\n  private _isLocked = false // same as isStopped but enabled/disabled when scroll reaches target\n  private _preventNextNativeScrollEvent = false\n  private _resetVelocityTimeout: ReturnType<typeof setTimeout> | null = null\n  private _rafId: number | null = null\n\n  /**\n   * Whether or not the user is touching the screen\n   */\n  isTouching?: boolean\n  /**\n   * The time in ms since the lenis instance was created\n   */\n  time = 0\n  /**\n   * User data that will be forwarded through the scroll event\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   userData: {\n   *     foo: 'bar'\n   *   }\n   * })\n   */\n  userData: UserData = {}\n  /**\n   * The last velocity of the scroll\n   */\n  lastVelocity = 0\n  /**\n   * The current velocity of the scroll\n   */\n  velocity = 0\n  /**\n   * The direction of the scroll\n   */\n  direction: 1 | -1 | 0 = 0\n  /**\n   * The options passed to the lenis instance\n   */\n  options: OptionalPick<\n    Required<LenisOptions>,\n    'duration' | 'easing' | 'prevent' | 'virtualScroll'\n  >\n  /**\n   * The target scroll value\n   */\n  targetScroll: number\n  /**\n   * The animated scroll value\n   */\n  animatedScroll: number\n\n  // These are instanciated here as they don't need information from the options\n  private readonly animate = new Animate()\n  private readonly emitter = new Emitter()\n  // These are instanciated in the constructor as they need information from the options\n  readonly dimensions: Dimensions // This is not private because it's used in the Snap class\n  private readonly virtualScroll: VirtualScroll\n\n  constructor({\n    wrapper = window,\n    content = document.documentElement,\n    eventsTarget = wrapper,\n    smoothWheel = true,\n    syncTouch = false,\n    syncTouchLerp = 0.075,\n    touchInertiaExponent = 1.7,\n    duration, // in seconds\n    easing,\n    lerp = 0.1,\n    infinite = false,\n    orientation = 'vertical', // vertical, horizontal\n    gestureOrientation = orientation === 'horizontal' ? 'both' : 'vertical', // vertical, horizontal, both\n    touchMultiplier = 1,\n    wheelMultiplier = 1,\n    autoResize = true,\n    prevent,\n    virtualScroll,\n    overscroll = true,\n    autoRaf = false,\n    anchors = false,\n    autoToggle = false, // https://caniuse.com/?search=transition-behavior\n    allowNestedScroll = false,\n    // @ts-ignore: this will be deprecated in the future\n    __experimental__naiveDimensions = false,\n    naiveDimensions = __experimental__naiveDimensions,\n    stopInertiaOnNavigate = false,\n  }: LenisOptions = {}) {\n    // Set version\n    window.lenisVersion = version\n\n    // Check if wrapper is <html>, fallback to window\n    if (!wrapper || wrapper === document.documentElement) {\n      wrapper = window\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    // Setup options\n    this.options = {\n      wrapper,\n      content,\n      eventsTarget,\n      smoothWheel,\n      syncTouch,\n      syncTouchLerp,\n      touchInertiaExponent,\n      duration,\n      easing,\n      lerp,\n      infinite,\n      gestureOrientation,\n      orientation,\n      touchMultiplier,\n      wheelMultiplier,\n      autoResize,\n      prevent,\n      virtualScroll,\n      overscroll,\n      autoRaf,\n      anchors,\n      autoToggle,\n      allowNestedScroll,\n      naiveDimensions,\n      stopInertiaOnNavigate,\n    }\n\n    // Setup dimensions instance\n    this.dimensions = new Dimensions(wrapper, content, { autoResize })\n\n    // Setup class name\n    this.updateClassName()\n\n    // Set the initial scroll value for all scroll information\n    this.targetScroll = this.animatedScroll = this.actualScroll\n\n    // Add event listeners\n    this.options.wrapper.addEventListener('scroll', this.onNativeScroll, false)\n\n    this.options.wrapper.addEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.addEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.options.wrapper.addEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    // Setup virtual scroll instance\n    this.virtualScroll = new VirtualScroll(eventsTarget as HTMLElement, {\n      touchMultiplier,\n      wheelMultiplier,\n    })\n    this.virtualScroll.on('scroll', this.onVirtualScroll)\n\n    if (this.options.autoToggle) {\n      this.checkOverflow()\n      this.rootElement.addEventListener('transitionend', this.onTransitionEnd, {\n        passive: true,\n      })\n    }\n\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Destroy the lenis instance, remove all event listeners and clean up the class name\n   */\n  destroy() {\n    this.emitter.destroy()\n\n    this.options.wrapper.removeEventListener(\n      'scroll',\n      this.onNativeScroll,\n      false\n    )\n\n    this.options.wrapper.removeEventListener('scrollend', this.onScrollEnd, {\n      capture: true,\n    })\n\n    this.options.wrapper.removeEventListener(\n      'pointerdown',\n      this.onPointerDown as EventListener,\n      false\n    )\n\n    if (this.options.anchors || this.options.stopInertiaOnNavigate) {\n      this.options.wrapper.removeEventListener(\n        'click',\n        this.onClick as EventListener,\n        false\n      )\n    }\n\n    this.virtualScroll.destroy()\n    this.dimensions.destroy()\n\n    this.cleanUpClassName()\n\n    if (this._rafId) {\n      cancelAnimationFrame(this._rafId)\n    }\n  }\n\n  /**\n   * Add an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  on(event: 'scroll', callback: ScrollCallback): () => void\n  on(event: 'virtual-scroll', callback: VirtualScrollCallback): () => void\n  on(event: LenisEvent, callback: any) {\n    return this.emitter.on(event, callback)\n  }\n\n  /**\n   * Remove an event listener for the given event and callback\n   *\n   * @param event Event name\n   * @param callback Callback function\n   */\n  off(event: 'scroll', callback: ScrollCallback): void\n  off(event: 'virtual-scroll', callback: VirtualScrollCallback): void\n  off(event: LenisEvent, callback: any) {\n    return this.emitter.off(event, callback)\n  }\n\n  private onScrollEnd = (e: Event | CustomEvent) => {\n    if (!(e instanceof CustomEvent)) {\n      if (this.isScrolling === 'smooth' || this.isScrolling === false) {\n        e.stopPropagation()\n      }\n    }\n  }\n\n  private dispatchScrollendEvent = () => {\n    this.options.wrapper.dispatchEvent(\n      new CustomEvent('scrollend', {\n        bubbles: this.options.wrapper === window,\n        // cancelable: false,\n        detail: {\n          lenisScrollEnd: true,\n        },\n      })\n    )\n  }\n\n  get overflow() {\n    const property = this.isHorizontal ? 'overflow-x' : 'overflow-y'\n    return getComputedStyle(this.rootElement)[\n      property as keyof CSSStyleDeclaration\n    ] as string\n  }\n\n  private checkOverflow() {\n    if (['hidden', 'clip'].includes(this.overflow)) {\n      this.internalStop()\n    } else {\n      this.internalStart()\n    }\n  }\n\n  private onTransitionEnd = (event: TransitionEvent) => {\n    if (event.propertyName.includes('overflow')) {\n      this.checkOverflow()\n    }\n  }\n\n  private setScroll(scroll: number) {\n    // behavior: 'instant' bypasses the scroll-behavior CSS property\n\n    if (this.isHorizontal) {\n      this.options.wrapper.scrollTo({ left: scroll, behavior: 'instant' })\n    } else {\n      this.options.wrapper.scrollTo({ top: scroll, behavior: 'instant' })\n    }\n  }\n\n  private onClick = (event: PointerEvent | MouseEvent) => {\n    const path = event.composedPath()\n\n    // filter anchor elements (elements with a valid href attribute)\n    const anchorElements = path.filter(\n      (node) => node instanceof HTMLAnchorElement && node.getAttribute('href')\n    ) as HTMLAnchorElement[]\n\n    if (this.options.anchors) {\n      const anchor = anchorElements.find((node) =>\n        node.getAttribute('href')?.includes('#')\n      )\n      if (anchor) {\n        const href = anchor.getAttribute('href')\n\n        if (href) {\n          const options =\n            typeof this.options.anchors === 'object' && this.options.anchors\n              ? this.options.anchors\n              : undefined\n\n          const target = `#${href.split('#')[1]}`\n\n          this.scrollTo(target, options)\n        }\n      }\n    }\n\n    if (this.options.stopInertiaOnNavigate) {\n      const internalLink = anchorElements.find(\n        (node) => node.host === window.location.host\n      )\n\n      if (internalLink) {\n        this.reset()\n      }\n    }\n  }\n\n  private onPointerDown = (event: PointerEvent | MouseEvent) => {\n    if (event.button === 1) {\n      this.reset()\n    }\n  }\n\n  private onVirtualScroll = (data: VirtualScrollData) => {\n    if (\n      typeof this.options.virtualScroll === 'function' &&\n      this.options.virtualScroll(data) === false\n    )\n      return\n\n    const { deltaX, deltaY, event } = data\n\n    this.emitter.emit('virtual-scroll', { deltaX, deltaY, event })\n\n    // keep zoom feature\n    if (event.ctrlKey) return\n    // @ts-ignore\n    if (event.lenisStopPropagation) return\n\n    const isTouch = event.type.includes('touch')\n    const isWheel = event.type.includes('wheel')\n\n    this.isTouching = event.type === 'touchstart' || event.type === 'touchmove'\n    // if (event.type === 'touchend') {\n    //   console.log('touchend', this.scroll)\n    //   // this.lastVelocity = this.velocity\n    //   // this.velocity = 0\n    //   // this.isScrolling = false\n    //   this.emit({ type: 'touchend' })\n    //   // alert('touchend')\n    //   return\n    // }\n\n    const isClickOrTap = deltaX === 0 && deltaY === 0\n\n    const isTapToStop =\n      this.options.syncTouch &&\n      isTouch &&\n      event.type === 'touchstart' &&\n      isClickOrTap &&\n      !this.isStopped &&\n      !this.isLocked\n\n    if (isTapToStop) {\n      this.reset()\n      return\n    }\n\n    // const isPullToRefresh =\n    //   this.options.gestureOrientation === 'vertical' &&\n    //   this.scroll === 0 &&\n    //   !this.options.infinite &&\n    //   deltaY <= 5 // touch pull to refresh, not reliable yet\n\n    const isUnknownGesture =\n      (this.options.gestureOrientation === 'vertical' && deltaY === 0) ||\n      (this.options.gestureOrientation === 'horizontal' && deltaX === 0)\n\n    if (isClickOrTap || isUnknownGesture) {\n      // console.log('prevent')\n      return\n    }\n\n    // catch if scrolling on nested scroll elements\n    let composedPath = event.composedPath()\n    composedPath = composedPath.slice(0, composedPath.indexOf(this.rootElement)) // remove parents elements\n\n    const prevent = this.options.prevent\n\n    if (\n      !!composedPath.find(\n        (node) =>\n          node instanceof HTMLElement &&\n          ((typeof prevent === 'function' && prevent?.(node)) ||\n            node.hasAttribute?.('data-lenis-prevent') ||\n            (isTouch && node.hasAttribute?.('data-lenis-prevent-touch')) ||\n            (isWheel && node.hasAttribute?.('data-lenis-prevent-wheel')) ||\n            (this.options.allowNestedScroll &&\n              this.checkNestedScroll(node, { deltaX, deltaY })))\n      )\n    )\n      return\n\n    if (this.isStopped || this.isLocked) {\n      if (event.cancelable) {\n        event.preventDefault() // this will stop forwarding the event to the parent, this is problematic\n      }\n      return\n    }\n\n    const isSmooth =\n      (this.options.syncTouch && isTouch) ||\n      (this.options.smoothWheel && isWheel)\n\n    if (!isSmooth) {\n      this.isScrolling = 'native'\n      this.animate.stop()\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      return\n    }\n\n    let delta = deltaY\n    if (this.options.gestureOrientation === 'both') {\n      delta = Math.abs(deltaY) > Math.abs(deltaX) ? deltaY : deltaX\n    } else if (this.options.gestureOrientation === 'horizontal') {\n      delta = deltaX\n    }\n\n    if (\n      !this.options.overscroll ||\n      this.options.infinite ||\n      (this.options.wrapper !== window &&\n        this.limit > 0 &&\n        ((this.animatedScroll > 0 && this.animatedScroll < this.limit) ||\n          (this.animatedScroll === 0 && deltaY > 0) ||\n          (this.animatedScroll === this.limit && deltaY < 0)))\n    ) {\n      // @ts-ignore\n      event.lenisStopPropagation = true\n      // event.stopPropagation()\n    }\n\n    if (event.cancelable) {\n      event.preventDefault()\n    }\n\n    const isSyncTouch = isTouch && this.options.syncTouch\n    const isTouchEnd = isTouch && event.type === 'touchend'\n\n    const hasTouchInertia = isTouchEnd\n\n    if (hasTouchInertia) {\n      // delta = this.velocity * this.options.touchInertiaMultiplier\n      delta =\n        Math.sign(this.velocity) *\n        Math.pow(Math.abs(this.velocity), this.options.touchInertiaExponent)\n    }\n\n    this.scrollTo(this.targetScroll + delta, {\n      programmatic: false,\n      ...(isSyncTouch\n        ? {\n            lerp: hasTouchInertia ? this.options.syncTouchLerp : 1,\n          }\n        : {\n            lerp: this.options.lerp,\n            duration: this.options.duration,\n            easing: this.options.easing,\n          }),\n    })\n  }\n\n  /**\n   * Force lenis to recalculate the dimensions\n   */\n  resize() {\n    this.dimensions.resize()\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.emit()\n  }\n\n  private emit() {\n    this.emitter.emit('scroll', this)\n  }\n\n  private onNativeScroll = () => {\n    if (this._resetVelocityTimeout !== null) {\n      clearTimeout(this._resetVelocityTimeout)\n      this._resetVelocityTimeout = null\n    }\n\n    if (this._preventNextNativeScrollEvent) {\n      this._preventNextNativeScrollEvent = false\n      return\n    }\n\n    if (this.isScrolling === false || this.isScrolling === 'native') {\n      const lastScroll = this.animatedScroll\n      this.animatedScroll = this.targetScroll = this.actualScroll\n      this.lastVelocity = this.velocity\n      this.velocity = this.animatedScroll - lastScroll\n      this.direction = Math.sign(\n        this.animatedScroll - lastScroll\n      ) as Lenis['direction']\n\n      if (!this.isStopped) {\n        this.isScrolling = 'native'\n      }\n\n      this.emit()\n\n      if (this.velocity !== 0) {\n        this._resetVelocityTimeout = setTimeout(() => {\n          this.lastVelocity = this.velocity\n          this.velocity = 0\n          this.isScrolling = false\n          this.emit()\n        }, 400)\n      }\n    }\n  }\n\n  private reset() {\n    this.isLocked = false\n    this.isScrolling = false\n    this.animatedScroll = this.targetScroll = this.actualScroll\n    this.lastVelocity = this.velocity = 0\n    this.animate.stop()\n  }\n\n  /**\n   * Start lenis scroll after it has been stopped\n   */\n  start() {\n    if (!this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.removeProperty('overflow')\n      return\n    }\n\n    this.internalStart()\n  }\n\n  private internalStart() {\n    if (!this.isStopped) return\n\n    this.reset()\n    this.isStopped = false\n    this.emit()\n  }\n\n  /**\n   * Stop lenis scroll\n   */\n  stop() {\n    if (this.isStopped) return\n\n    if (this.options.autoToggle) {\n      this.rootElement.style.setProperty('overflow', 'clip')\n      return\n    }\n\n    this.internalStop()\n  }\n\n  private internalStop() {\n    if (this.isStopped) return\n\n    this.reset()\n    this.isStopped = true\n    this.emit()\n  }\n\n  /**\n   * RequestAnimationFrame for lenis\n   *\n   * @param time The time in ms from an external clock like `requestAnimationFrame` or Tempus\n   */\n  raf = (time: number) => {\n    const deltaTime = time - (this.time || time)\n    this.time = time\n\n    this.animate.advance(deltaTime * 0.001)\n\n    if (this.options.autoRaf) {\n      this._rafId = requestAnimationFrame(this.raf)\n    }\n  }\n\n  /**\n   * Scroll to a target value\n   *\n   * @param target The target value to scroll to\n   * @param options The options for the scroll\n   *\n   * @example\n   * lenis.scrollTo(100, {\n   *   offset: 100,\n   *   duration: 1,\n   *   easing: (t) => 1 - Math.cos((t * Math.PI) / 2),\n   *   lerp: 0.1,\n   *   onStart: () => {\n   *     console.log('onStart')\n   *   },\n   *   onComplete: () => {\n   *     console.log('onComplete')\n   *   },\n   * })\n   */\n  scrollTo(\n    target: number | string | HTMLElement,\n    {\n      offset = 0,\n      immediate = false,\n      lock = false,\n      programmatic = true, // called from outside of the class\n      lerp = programmatic ? this.options.lerp : undefined,\n      duration = programmatic ? this.options.duration : undefined,\n      easing = programmatic ? this.options.easing : undefined,\n      onStart,\n      onComplete,\n      force = false, // scroll even if stopped\n      userData,\n    }: ScrollToOptions = {}\n  ) {\n    if ((this.isStopped || this.isLocked) && !force) return\n\n    // keywords\n    if (\n      typeof target === 'string' &&\n      ['top', 'left', 'start', '#'].includes(target)\n    ) {\n      target = 0\n    } else if (\n      typeof target === 'string' &&\n      ['bottom', 'right', 'end'].includes(target)\n    ) {\n      target = this.limit\n    } else {\n      let node\n\n      if (typeof target === 'string') {\n        // CSS selector\n        node = document.querySelector(target)\n\n        if (!node) {\n          if (target === '#top') {\n            target = 0\n          } else {\n            console.warn('Lenis: Target not found', target)\n          }\n        }\n      } else if (target instanceof HTMLElement && target?.nodeType) {\n        // Node element\n        node = target\n      }\n\n      if (node) {\n        if (this.options.wrapper !== window) {\n          // nested scroll offset correction\n          const wrapperRect = this.rootElement.getBoundingClientRect()\n          offset -= this.isHorizontal ? wrapperRect.left : wrapperRect.top\n        }\n\n        const rect = node.getBoundingClientRect()\n\n        target =\n          (this.isHorizontal ? rect.left : rect.top) + this.animatedScroll\n      }\n    }\n\n    if (typeof target !== 'number') return\n\n    target += offset\n    target = Math.round(target)\n\n    if (this.options.infinite) {\n      if (programmatic) {\n        this.targetScroll = this.animatedScroll = this.scroll\n\n        const distance = target - this.animatedScroll\n\n        if (distance > this.limit / 2) {\n          target = target - this.limit\n        } else if (distance < -this.limit / 2) {\n          target = target + this.limit\n        }\n      }\n    } else {\n      target = clamp(0, target, this.limit)\n    }\n\n    if (target === this.targetScroll) {\n      onStart?.(this)\n      onComplete?.(this)\n      return\n    }\n\n    this.userData = userData ?? {}\n\n    if (immediate) {\n      this.animatedScroll = this.targetScroll = target\n      this.setScroll(this.scroll)\n      this.reset()\n      this.preventNextNativeScrollEvent()\n      this.emit()\n      onComplete?.(this)\n      this.userData = {}\n\n      requestAnimationFrame(() => {\n        this.dispatchScrollendEvent()\n      })\n      return\n    }\n\n    if (!programmatic) {\n      this.targetScroll = target\n    }\n\n    // flip to easing/time based animation if at least one of them is provided\n    if (typeof duration === 'number' && typeof easing !== 'function') {\n      easing = defaultEasing\n    } else if (typeof easing === 'function' && typeof duration !== 'number') {\n      duration = 1\n    }\n\n    this.animate.fromTo(this.animatedScroll, target, {\n      duration,\n      easing,\n      lerp,\n      onStart: () => {\n        // started\n        if (lock) this.isLocked = true\n        this.isScrolling = 'smooth'\n        onStart?.(this)\n      },\n      onUpdate: (value: number, completed: boolean) => {\n        this.isScrolling = 'smooth'\n\n        // updated\n        this.lastVelocity = this.velocity\n        this.velocity = value - this.animatedScroll\n        this.direction = Math.sign(this.velocity) as Lenis['direction']\n\n        this.animatedScroll = value\n        this.setScroll(this.scroll)\n\n        if (programmatic) {\n          // wheel during programmatic should stop it\n          this.targetScroll = value\n        }\n\n        if (!completed) this.emit()\n\n        if (completed) {\n          this.reset()\n          this.emit()\n          onComplete?.(this)\n          this.userData = {}\n\n          requestAnimationFrame(() => {\n            this.dispatchScrollendEvent()\n          })\n\n          // avoid emitting event twice\n          this.preventNextNativeScrollEvent()\n        }\n      },\n    })\n  }\n\n  private preventNextNativeScrollEvent() {\n    this._preventNextNativeScrollEvent = true\n\n    requestAnimationFrame(() => {\n      this._preventNextNativeScrollEvent = false\n    })\n  }\n\n  private checkNestedScroll(\n    node: HTMLElement,\n    { deltaX, deltaY }: { deltaX: number; deltaY: number }\n  ) {\n    const time = Date.now()\n\n    // @ts-ignore\n    const cache = (node._lenis ??= {})\n\n    let hasOverflowX,\n      hasOverflowY,\n      isScrollableX,\n      isScrollableY,\n      scrollWidth,\n      scrollHeight,\n      clientWidth,\n      clientHeight\n\n    const gestureOrientation = this.options.gestureOrientation\n\n    if (time - (cache.time ?? 0) > 2000) {\n      cache.time = Date.now()\n\n      const computedStyle = window.getComputedStyle(node)\n      cache.computedStyle = computedStyle\n\n      const overflowXString = computedStyle.overflowX\n      const overflowYString = computedStyle.overflowY\n\n      hasOverflowX = ['auto', 'overlay', 'scroll'].includes(overflowXString)\n      hasOverflowY = ['auto', 'overlay', 'scroll'].includes(overflowYString)\n      cache.hasOverflowX = hasOverflowX\n      cache.hasOverflowY = hasOverflowY\n\n      if (!hasOverflowX && !hasOverflowY) return false // if no overflow, it's not scrollable no matter what, early return saves some computations\n      if (gestureOrientation === 'vertical' && !hasOverflowY) return false\n      if (gestureOrientation === 'horizontal' && !hasOverflowX) return false\n\n      scrollWidth = node.scrollWidth\n      scrollHeight = node.scrollHeight\n\n      clientWidth = node.clientWidth\n      clientHeight = node.clientHeight\n\n      isScrollableX = scrollWidth > clientWidth\n      isScrollableY = scrollHeight > clientHeight\n\n      cache.isScrollableX = isScrollableX\n      cache.isScrollableY = isScrollableY\n      cache.scrollWidth = scrollWidth\n      cache.scrollHeight = scrollHeight\n      cache.clientWidth = clientWidth\n      cache.clientHeight = clientHeight\n    } else {\n      isScrollableX = cache.isScrollableX\n      isScrollableY = cache.isScrollableY\n      hasOverflowX = cache.hasOverflowX\n      hasOverflowY = cache.hasOverflowY\n      scrollWidth = cache.scrollWidth\n      scrollHeight = cache.scrollHeight\n      clientWidth = cache.clientWidth\n      clientHeight = cache.clientHeight\n    }\n\n    if (\n      (!hasOverflowX && !hasOverflowY) ||\n      (!isScrollableX && !isScrollableY)\n    ) {\n      return false\n    }\n\n    if (gestureOrientation === 'vertical' && (!hasOverflowY || !isScrollableY))\n      return false\n\n    if (\n      gestureOrientation === 'horizontal' &&\n      (!hasOverflowX || !isScrollableX)\n    )\n      return false\n\n    let orientation: 'x' | 'y' | undefined\n\n    if (gestureOrientation === 'horizontal') {\n      orientation = 'x'\n    } else if (gestureOrientation === 'vertical') {\n      orientation = 'y'\n    } else {\n      const isScrollingX = deltaX !== 0\n      const isScrollingY = deltaY !== 0\n\n      if (isScrollingX && hasOverflowX && isScrollableX) {\n        orientation = 'x'\n      }\n\n      if (isScrollingY && hasOverflowY && isScrollableY) {\n        orientation = 'y'\n      }\n    }\n\n    if (!orientation) return false\n\n    let scroll, maxScroll, delta, hasOverflow, isScrollable\n\n    if (orientation === 'x') {\n      scroll = node.scrollLeft\n      maxScroll = scrollWidth - clientWidth\n      delta = deltaX\n\n      hasOverflow = hasOverflowX\n      isScrollable = isScrollableX\n    } else if (orientation === 'y') {\n      scroll = node.scrollTop\n      maxScroll = scrollHeight - clientHeight\n      delta = deltaY\n\n      hasOverflow = hasOverflowY\n      isScrollable = isScrollableY\n    } else {\n      return false\n    }\n\n    const willScroll = delta > 0 ? scroll < maxScroll : scroll > 0\n\n    return willScroll && hasOverflow && isScrollable\n  }\n\n  /**\n   * The root element on which lenis is instanced\n   */\n  get rootElement() {\n    return (\n      this.options.wrapper === window\n        ? document.documentElement\n        : this.options.wrapper\n    ) as HTMLElement\n  }\n\n  /**\n   * The limit which is the maximum scroll value\n   */\n  get limit() {\n    if (this.options.naiveDimensions) {\n      if (this.isHorizontal) {\n        return this.rootElement.scrollWidth - this.rootElement.clientWidth\n      } else {\n        return this.rootElement.scrollHeight - this.rootElement.clientHeight\n      }\n    } else {\n      return this.dimensions.limit[this.isHorizontal ? 'x' : 'y']\n    }\n  }\n\n  /**\n   * Whether or not the scroll is horizontal\n   */\n  get isHorizontal() {\n    return this.options.orientation === 'horizontal'\n  }\n\n  /**\n   * The actual scroll value\n   */\n  get actualScroll() {\n    // value browser takes into account\n    // it has to be this way because of DOCTYPE declaration\n    const wrapper = this.options.wrapper as Window | HTMLElement\n\n    return this.isHorizontal\n      ? (wrapper as Window).scrollX ?? (wrapper as HTMLElement).scrollLeft\n      : (wrapper as Window).scrollY ?? (wrapper as HTMLElement).scrollTop\n  }\n\n  /**\n   * The current scroll value\n   */\n  get scroll() {\n    return this.options.infinite\n      ? modulo(this.animatedScroll, this.limit)\n      : this.animatedScroll\n  }\n\n  /**\n   * The progress of the scroll relative to the limit\n   */\n  get progress() {\n    // avoid progress to be NaN\n    return this.limit === 0 ? 1 : this.scroll / this.limit\n  }\n\n  /**\n   * Current scroll state\n   */\n  get isScrolling() {\n    return this._isScrolling\n  }\n\n  private set isScrolling(value: Scrolling) {\n    if (this._isScrolling !== value) {\n      this._isScrolling = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is stopped\n   */\n  get isStopped() {\n    return this._isStopped\n  }\n\n  private set isStopped(value: boolean) {\n    if (this._isStopped !== value) {\n      this._isStopped = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is locked\n   */\n  get isLocked() {\n    return this._isLocked\n  }\n\n  private set isLocked(value: boolean) {\n    if (this._isLocked !== value) {\n      this._isLocked = value\n      this.updateClassName()\n    }\n  }\n\n  /**\n   * Check if lenis is smooth scrolling\n   */\n  get isSmooth() {\n    return this.isScrolling === 'smooth'\n  }\n\n  /**\n   * The class name applied to the wrapper element\n   */\n  get className() {\n    let className = 'lenis'\n    if (this.options.autoToggle) className += ' lenis-autoToggle'\n    if (this.isStopped) className += ' lenis-stopped'\n    if (this.isLocked) className += ' lenis-locked'\n    if (this.isScrolling) className += ' lenis-scrolling'\n    if (this.isScrolling === 'smooth') className += ' lenis-smooth'\n    return className\n  }\n\n  private updateClassName() {\n    this.cleanUpClassName()\n\n    this.rootElement.className =\n      `${this.rootElement.className} ${this.className}`.trim()\n  }\n\n  private cleanUpClassName() {\n    this.rootElement.className = this.rootElement.className\n      .replace(/lenis(-\\w+)?/g, '')\n      .trim()\n  }\n}\n","{\n  \"name\": \"lenis\",\n  \"version\": \"1.3.17\",\n  \"description\": \"How smooth scroll should be\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"author\": \"darkroom.engineering\",\n  \"license\": \"MIT\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/darkroomengineering/lenis.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/darkroomengineering/lenis/issues\"\n  },\n  \"homepage\": \"https://github.com/darkroomengineering/lenis\",\n  \"funding\": {\n    \"type\": \"github\",\n    \"url\": \"https://github.com/sponsors/darkroomengineering\"\n  },\n  \"keywords\": [\n    \"scroll\",\n    \"smooth\",\n    \"lenis\",\n    \"react\",\n    \"vue\"\n  ],\n  \"scripts\": {\n    \"build\": \"pnpm build:core && pnpm build:all\",\n    \"build:core\": \"tsup --config tsup.core.ts\",\n    \"build:all\": \"tsup\",\n    \"dev\": \"pnpm run -w --parallel /^dev:.*/\",\n    \"dev:build\": \"tsup --watch\",\n    \"dev:playground\": \"pnpm --filter playground dev\",\n    \"dev:nuxt\": \"pnpm --filter playground-nuxt dev\",\n    \"readme\": \"node ./scripts/update-readme.js\",\n    \"version:framer\": \"npm version prerelease --preid framer --force --no-git-tag-version\",\n    \"version:dev\": \"npm version prerelease --preid dev --force --no-git-tag-version\",\n    \"version:patch\": \"npm version patch --force --no-git-tag-version\",\n    \"version:minor\": \"npm version minor --force --no-git-tag-version\",\n    \"version:major\": \"npm version major --force --no-git-tag-version\",\n    \"postversion\": \"pnpm build && pnpm readme\",\n    \"publish:dev\": \"npm publish --tag dev\",\n    \"publish:framer\": \"npm publish --tag framer\",\n    \"publish:main\": \"npm publish\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"devDependencies\": {\n    \"terser\": \"^5.37.0\",\n    \"tsup\": \"^8.3.5\",\n    \"typescript\": \"^5.7.3\"\n  },\n  \"peerDependencies\": {\n    \"react\": \">=17.0.0\",\n    \"vue\": \">=3.0.0\",\n    \"@nuxt/kit\": \">=3.0.0\"\n  },\n  \"peerDependenciesMeta\": {\n    \"react\": {\n      \"optional\": true\n    },\n    \"vue\": {\n      \"optional\": true\n    },\n    \"@nuxt/kit\": {\n      \"optional\": true\n    }\n  },\n  \"unpkg\": \"./dist/lenis.mjs\",\n  \"main\": \"./dist/lenis.mjs\",\n  \"module\": \"./dist/lenis.mjs\",\n  \"types\": \"./dist/lenis.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/lenis.d.ts\",\n      \"default\": \"./dist/lenis.mjs\"\n    },\n    \"./react\": {\n      \"types\": \"./dist/lenis-react.d.ts\",\n      \"default\": \"./dist/lenis-react.mjs\"\n    },\n    \"./snap\": {\n      \"types\": \"./dist/lenis-snap.d.ts\",\n      \"default\": \"./dist/lenis-snap.mjs\"\n    },\n    \"./vue\": {\n      \"types\": \"./dist/lenis-vue.d.ts\",\n      \"default\": \"./dist/lenis-vue.mjs\"\n    },\n    \"./nuxt\": {\n      \"default\": \"./dist/lenis-vue-nuxt.mjs\"\n    },\n    \"./nuxt/runtime/*\": {\n      \"default\": \"./dist/nuxt/runtime/*.mjs\"\n    },\n    \"./dist/*\": \"./dist/*\"\n  }\n}\n","/**\n * Intersection Observer\n *\n * Detecting visibility of an element in the viewport.\n *\n * Features functions to:\n *\n * - Trigger inview/outOfView callbacks\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\n *\n * References:\n *\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\n */\n\nimport type { IIOOptions } from '../types';\nimport ScrollElement from './ScrollElement';\n\nexport default class IO {\n    public scrollElements: ScrollElement[];\n    private rootMargin: string;\n    private root: HTMLElement | null;\n    private IORaf: boolean;\n    private observer!: IntersectionObserver;\n\n    constructor({\n        scrollElements,\n        rootMargin = '-1px -1px -1px -1px',\n        root = null,\n        IORaf,\n    }: IIOOptions) {\n        // Parameters\n        this.scrollElements = scrollElements;\n        this.rootMargin = rootMargin;\n        this.root = root;\n        this.IORaf = IORaf;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize Intersection Observer.\n     *\n     * @private\n     */\n    private _init() {\n        // Options\n        const observerOptions = {\n            root: this.root,\n            rootMargin: this.rootMargin,\n        };\n\n        // Callback\n        const onIntersect = (entries: IntersectionObserverEntry[]) => {\n            entries.forEach((entry) => {\n                const $targetItem: ScrollElement | undefined =\n                    this.scrollElements.find(\n                        (item) => item.$el === entry.target\n                    );\n\n                if (entry.isIntersecting) {\n                    $targetItem && ($targetItem.isAlreadyIntersected = true);\n                    this._setInview(entry);\n                } else if ($targetItem && $targetItem.isAlreadyIntersected) {\n                    this._setOutOfView(entry);\n                }\n            });\n        };\n\n        // Instance\n        this.observer = new IntersectionObserver(onIntersect, observerOptions);\n\n        // Observe each default elements\n        for (const scrollElement of this.scrollElements) {\n            const $scrollElement = scrollElement.$el;\n            this.observe($scrollElement);\n        }\n    }\n\n    /**\n     * Lifecyle - Destroy Intersection Observer.\n     */\n    public destroy() {\n        this.observer.disconnect();\n    }\n\n    /**\n     * Subscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to observe.\n     */\n    public observe($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.observe($scrollElement);\n    }\n\n    /**\n     * Unsubscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\n     */\n    public unobserve($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.unobserve($scrollElement);\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger inview callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setInview(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOn();\n        !this.IORaf && scrollElement?.setInview();\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger out of view callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setOutOfView(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOff();\n        !this.IORaf && scrollElement?.setOutOfView();\n\n        // Unobserve if element doesn't have repeat attribute\n        if (!scrollElement?.attributes.scrollRepeat && !this.IORaf) {\n            this.unobserve(entry.target as HTMLElement);\n        }\n    }\n}\n","// https://greensock.com/docs/v3/GSAP/gsap.utils\n\n/**\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\n *\n * @param {number} min   - Minimum value expected.\n * @param {number} max   - Maximum value expected.\n * @param {number} value - Current value.\n *\n * @returns {number} - Clamped value.\n */\nexport function clamp(min: number, max: number, value: number): number {\n    return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\n *\n * @param {number} inMin  - Current minimum value.\n * @param {number} inMax  - Current maximum value.\n * @param {number} outMin - Maximum value expected.\n * @param {number} outMax - Maximum value expected.\n * @param {number} value  - Current value.\n *\n * @returns {number} - New value that should be between minimum value expected and maximum value.\n */\nexport function mapRange(\n    inMin: number,\n    inMax: number,\n    outMin: number,\n    outMax: number,\n    value: number\n): number {\n    const inRange = inMax - inMin;\n    const outRange = outMax - outMin;\n    return outMin + (((value - inMin) / inRange) * outRange || 0);\n}\n\n/**\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\n *\n * @param {number} min   - Current minimum value.\n * @param {number} max   - Current maximum value.\n * @param {number} value - Current value.\n *\n * @returns {number} - New value that should be between 0 and 1.\n */\nexport function normalize(min: number, max: number, value: number): number {\n    return mapRange(min, max, 0, 1, value);\n}\n\n/**\n * Get closest number from an array.\n *\n * @param {number[]} array  - Numbers array.\n * @param {number}   target - Reference value.\n *\n * @returns {number} - Closest number.\n */\nexport function closestNumber(array: number[], target: number): number {\n    return array.reduce((prev, curr) => {\n        return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\n    });\n}\n","/**\n * Scroll Element\n *\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\n *\n * Features functions to:\n *\n * - scrollClass - Add a custom class when the element is intersected by the offset\n * - scrollOffset - Determine offsets to intersect the element\n * - scrollPosition - Determine the element positions to consider an element as intersected.\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\n * - scrollEventProgress - Send scroll progress to custom event listeners.\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\n * - scrollCall - Call a custom event when the element is intersected\n */\n\nimport type {\n    IScrollElementOptions,\n    IScrollElementAttributes,\n    IScrollElementIntersection,\n    IScrollElementMetrics,\n    IScrollElementCallbacksValues,\n    scrollOrientation,\n} from '../types';\nimport { clamp, closestNumber, normalize, mapRange } from '../utils/maths';\n\n/** Constants */\nconst INVIEW_CLASS = 'is-inview';\nconst PROGRESS_CSS_VAR = '--progress';\n\nexport default class ScrollElement {\n    public $el: HTMLElement;\n    public id: number;\n    public needRaf: boolean;\n    public attributes: IScrollElementAttributes;\n    public scrollOrientation: scrollOrientation;\n    public isAlreadyIntersected: boolean;\n\n    private intersection: IScrollElementIntersection;\n    private metrics: IScrollElementMetrics;\n    private currentScroll: number;\n    private translateValue: number;\n    private progress: number;\n    private lastProgress: number | null;\n    private isInview: boolean;\n    private isInteractive: boolean;\n    private isInFold: boolean;\n    private isFirstResize: boolean;\n\n    private subscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n    private unsubscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n    private lenisInstance: any;\n\n    // Cached functions to avoid orientation checks every frame\n    private getWindowSize: () => number;\n    private getMetricsStart: (bcr: DOMRect) => number;\n    private getMetricsSize: (bcr: DOMRect) => number;\n\n    // Position handlers for intersection.start (includes wSize)\n    private readonly startPositionHandlers: Record<string, (offsetStart: number, wSize: number, viewport: number, size: number) => number> = {\n        'start': (offsetStart, wSize, viewport) => offsetStart - wSize + viewport,\n        'middle': (offsetStart, wSize, viewport, size) => offsetStart - wSize + viewport + size * 0.5,\n        'end': (offsetStart, wSize, viewport, size) => offsetStart - wSize + viewport + size,\n        'fold': () => 0,\n    };\n\n    // Position handlers for intersection.end (DOES NOT include wSize - critical difference)\n    private readonly endPositionHandlers: Record<string, (offsetStart: number, viewport: number, size: number) => number> = {\n        'start': (offsetStart, viewport) => offsetStart - viewport,\n        'middle': (offsetStart, viewport, size) => offsetStart - viewport + size * 0.5,\n        'end': (offsetStart, viewport, size) => offsetStart - viewport + size,\n    };\n\n    constructor({\n        $el,\n        id,\n        subscribeElementUpdateFn,\n        unsubscribeElementUpdateFn,\n        needRaf,\n        scrollOrientation,\n        lenisInstance,\n    }: IScrollElementOptions) {\n        // Scroll DOM element\n        this.$el = $el;\n        // Unique ID\n        this.id = id;\n        // RAF option\n        this.needRaf = needRaf;\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n        // Lenis instance\n        this.lenisInstance = lenisInstance;\n        // Parent's callbacks\n        this.subscribeElementUpdateFn = subscribeElementUpdateFn;\n        this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\n\n        // Attributes\n        this.attributes = {\n            scrollClass: this.$el.dataset['scrollClass'] ?? INVIEW_CLASS,\n            scrollOffset: this.$el.dataset['scrollOffset'] ?? '0,0',\n            scrollPosition: this.$el.dataset['scrollPosition'] ?? 'start,end',\n            scrollCssProgress: this.$el.dataset['scrollCssProgress'] !== undefined,\n            scrollEventProgress:\n                this.$el.dataset['scrollEventProgress'] ?? null,\n            scrollSpeed:\n                this.$el.dataset['scrollSpeed'] !== undefined\n                    ? parseFloat(this.$el.dataset['scrollSpeed'])\n                    : null,\n            scrollRepeat: this.$el.dataset['scrollRepeat'] !== undefined,\n            scrollCall: this.$el.dataset['scrollCall'] ?? null,\n            scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] !== undefined,\n            scrollEnableTouchSpeed:\n                this.$el.dataset['scrollEnableTouchSpeed'] !== undefined,\n        };\n\n        // Limits\n        this.intersection = {\n            start: 0,\n            end: 0,\n        };\n\n        // Metrics\n        this.metrics = {\n            offsetStart: 0,\n            offsetEnd: 0,\n            bcr: {} as DOMRect,\n        };\n\n        // Scroll Values\n        this.currentScroll = this.lenisInstance.scroll;\n\n        // Parallax\n        this.translateValue = 0;\n\n        // Progress\n        this.progress = 0;\n        this.lastProgress = null;\n\n        // Inview\n        this.isInview = false;\n        this.isInteractive = false;\n        this.isAlreadyIntersected = false;\n        this.isInFold = false;\n        this.isFirstResize = true;\n\n        // Cache orientation-dependent functions to avoid repeated conditionals\n        this.getWindowSize = this.scrollOrientation === 'vertical'\n            ? () => this.lenisInstance.dimensions.height\n            : () => this.lenisInstance.dimensions.width;\n\n        this.getMetricsStart = this.scrollOrientation === 'vertical'\n            ? (bcr: DOMRect) => bcr.top\n            : (bcr: DOMRect) => bcr.left;\n\n        this.getMetricsSize = this.scrollOrientation === 'vertical'\n            ? (bcr: DOMRect) => bcr.height\n            : (bcr: DOMRect) => bcr.width;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize progress tracking.\n     *\n     * @private\n     */\n    private _init() {\n        if (!this.needRaf) {\n            return;\n        }\n\n        // First resize to compute all values\n        this._resize();\n    }\n\n    /**\n     * Callback - Resize callback\n     */\n    public onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        this.currentScroll = currentScroll;\n        this._resize();\n    }\n\n    /**\n     * Callback - RAF callback\n     */\n    public onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        const wSize = this.getWindowSize();\n        this.currentScroll = currentScroll;\n        this._computeProgress();\n\n        // Parallax\n        if (\n            this.attributes.scrollSpeed &&\n            !isNaN(this.attributes.scrollSpeed)\n        ) {\n            // if touch detected or smooth disabled\n            if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\n                if (this.translateValue) {\n                    this.$el.style.transform = `translate3d(0, 0, 0)`;\n                }\n                this.translateValue = 0;\n\n            // if mousewheel or smooth enabled\n            } else {\n                // Check fold condition\n                if (this.isInFold) {\n                    const progress = Math.max(0, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                } else {\n                    const progress = mapRange(0, 1, -1, 1, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                }\n\n                this.$el.style.transform =\n                    this.scrollOrientation === 'vertical'\n                        ? `translate3d(0, ${this.translateValue}px, 0)`\n                        : `translate3d(${this.translateValue}px, 0, 0)`;\n            }\n        }\n    }\n\n    /**\n     * Inview callback\n     */\n    public setInview() {\n        if (this.isInview) {\n            return;\n        }\n\n        this.isInview = true;\n        this.$el.classList.add(this.attributes.scrollClass);\n\n        const way = 'enter';\n        const from = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Out of view callback\n     */\n    public setOutOfView() {\n        if (!(this.isInview && this.attributes.scrollRepeat)) {\n            return;\n        }\n\n        this.isInview = false;\n        this.$el.classList.remove(this.attributes.scrollClass);\n\n        const way = 'leave';\n        const from = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Switch interactivity on to subscribe the instance to the RAF\n     * and start calculations.\n     */\n    public setInteractivityOn() {\n        if (this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = true;\n        this.subscribeElementUpdateFn(this);\n    }\n\n    /**\n     * Switch interactivity off to unsubscribe the instance to the RAF\n     * and stop calculations.\n     */\n    public setInteractivityOff() {\n        if (!this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = false;\n        this.unsubscribeElementUpdateFn(this);\n\n        // Force progress to progress limit when the element is out\n        this.lastProgress !== null &&\n            this._computeProgress(closestNumber([0, 1], this.lastProgress));\n    }\n\n    /**\n     * Resize method that compute the element's values.\n     *\n     * @private\n     */\n    private _resize() {\n        this.metrics.bcr = this.$el.getBoundingClientRect();\n        this._computeMetrics();\n        this._computeIntersection();\n\n        // First resize logic\n        if (this.isFirstResize) {\n            this.isFirstResize = false;\n            // Dispatch default call if the element is in fold.\n            if (this.isInFold) {\n                this.setInview();\n            }\n        }\n    }\n\n    /**\n     * Compute element's offsets and determine if the element is in fold.\n     *\n     * @private\n     */\n    private _computeMetrics() {\n        const wSize = this.getWindowSize();\n        const metricsStart = this.getMetricsStart(this.metrics.bcr);\n        const metricsSize = this.getMetricsSize(this.metrics.bcr);\n\n        this.metrics.offsetStart =\n            this.currentScroll + metricsStart - this.translateValue;\n        this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\n\n        if (\n            this.metrics.offsetStart < wSize &&\n            !this.attributes.scrollIgnoreFold\n        ) {\n            this.isInFold = true;\n        } else {\n            this.isInFold = false;\n        }\n    }\n\n    /**\n     * Compute intersection values depending on the context.\n     * Uses handler-based approach for cleaner, more maintainable code.\n     *\n     * @private\n     */\n    private _computeIntersection() {\n        const wSize = this.getWindowSize();\n        const metricsSize = this.getMetricsSize(this.metrics.bcr);\n\n        // Parse offset\n        const offset = this.attributes.scrollOffset.split(',');\n        const offsetStart = offset[0]?.trim() ?? '0';\n        const offsetEnd = offset[1]?.trim() ?? '0';\n\n        // Parse positions\n        const scrollPosition = this.attributes.scrollPosition.split(',');\n        let scrollPositionStart = scrollPosition[0]?.trim() ?? 'start';\n        const scrollPositionEnd = scrollPosition[1]?.trim() ?? 'end';\n\n        // Calculate viewport offsets\n        const viewportStart = offsetStart.includes('%')\n            ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01\n            : parseInt(offsetStart);\n        const viewportEnd = offsetEnd.includes('%')\n            ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01\n            : parseInt(offsetEnd);\n\n        // Fold exception\n        if (this.isInFold) {\n            scrollPositionStart = 'fold';\n        }\n\n        // Calculate intersection.start using handlers\n        const startHandler = this.startPositionHandlers[scrollPositionStart];\n        this.intersection.start = startHandler\n            ? startHandler(this.metrics.offsetStart, wSize, viewportStart, metricsSize)\n            : this.metrics.offsetStart - wSize + viewportStart; // default fallback\n\n        // Calculate intersection.end using handlers\n        const endHandler = this.endPositionHandlers[scrollPositionEnd];\n        this.intersection.end = endHandler\n            ? endHandler(this.metrics.offsetStart, viewportEnd, metricsSize)\n            : this.metrics.offsetStart - viewportEnd + metricsSize; // default fallback\n\n        // Ensure end > start\n        if (this.intersection.end <= this.intersection.start) {\n            switch (scrollPositionEnd) {\n                case 'start':\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n                case 'middle':\n                    this.intersection.end = this.intersection.start + metricsSize * 0.5;\n                    break;\n                case 'end':\n                    this.intersection.end = this.intersection.start + metricsSize;\n                    break;\n                default:\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Compute the scroll progress of the element depending\n     * on its intersection values.\n     *\n     * @private\n     *\n     * @param {number} [forcedProgress] - Value to force progress.\n     */\n    private _computeProgress(forcedProgress?: number) {\n        // Progress\n        const progress =\n            forcedProgress ??\n            clamp(\n                0,\n                1,\n                normalize(\n                    this.intersection.start,\n                    this.intersection.end,\n                    this.currentScroll\n                )\n            );\n\n        this.progress = progress;\n\n        if (progress !== this.lastProgress) {\n            this.lastProgress = progress;\n\n            // Set the element's progress to the css variable\n            this.attributes.scrollCssProgress && this._setCssProgress(progress);\n\n            // Set the element's progress to the custom event listeners\n            this.attributes.scrollEventProgress &&\n                this._setCustomEventProgress(progress);\n\n            // Logic to trigger the inview/out of view callbacks\n            progress > 0 && progress < 1 && this.setInview();\n            progress === 0 && this.setOutOfView();\n            progress === 1 && this.setOutOfView();\n        }\n    }\n\n    /**\n     * Set the element's progress to a specific css variable.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCssProgress(currentProgress = 0) {\n        this.$el.style.setProperty(\n            PROGRESS_CSS_VAR,\n            currentProgress.toString()\n        );\n    }\n\n    /**\n     * Set the element's progress to the custom event listeners.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCustomEventProgress(currentProgress = 0) {\n        const customEventName = this.attributes.scrollEventProgress;\n\n        if (!customEventName) return;\n\n        const customEvent = new CustomEvent(customEventName, {\n            detail: {\n                target: this.$el,\n                progress: currentProgress,\n            },\n        });\n        window.dispatchEvent(customEvent);\n    }\n\n    /**\n     * Function to get scroll call from.\n     *\n     * @private\n     */\n    _getScrollCallFrom() {\n        const closestIntersectionValue = closestNumber(\n            [this.intersection.start, this.intersection.end],\n            this.currentScroll\n        );\n        return this.intersection.start === closestIntersectionValue\n            ? 'start'\n            : 'end';\n    }\n\n    /**\n     * Lifecyle - Destroy and cleanup the scroll element.\n     *\n     * Removes all CSS modifications and clears references to prevent memory leaks.\n     */\n    public destroy(): void {\n        // Remove CSS variables\n        if (this.attributes.scrollCssProgress) {\n            this.$el.style.removeProperty(PROGRESS_CSS_VAR);\n        }\n\n        // Remove transform if parallax was applied\n        if (this.attributes.scrollSpeed) {\n            this.$el.style.removeProperty('transform');\n        }\n\n        // Remove class if added\n        if (this.isInview && this.attributes.scrollClass) {\n            this.$el.classList.remove(this.attributes.scrollClass);\n        }\n    }\n\n    /**\n     * Function to dispatch a custom event.\n     *\n     * @private\n     *\n     * @param {string} way - Enter or leave.\n     * @param {string} from - Start or end.\n     */\n    _dispatchCall(way: string, from: string) {\n        const customEventName = this.attributes.scrollCall;\n\n        if (!customEventName) return;\n\n        // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n        const customEvent = new CustomEvent(customEventName, {\n            detail: {\n                target: this.$el,\n                way,\n                from,\n            },\n        });\n        window.dispatchEvent(customEvent);\n    }\n}\n","/**\n * Integrates Lenis with Locomotive's built-in animation system\n */\n\nimport type {\n    CoreOptions,\n    IScrollElementCallbacksValues,\n    scrollOrientation,\n} from '../types';\nimport IO from './IO';\nimport ScrollElement from './ScrollElement';\n\n/** Defined attributes that need a requestAnimationFrame */\nconst ATTRIBUTES_THAT_NEED_RAF = [\n    'scrollOffset',\n    'scrollPosition',\n    'scrollCssProgress',\n    'scrollEventProgress',\n    'scrollSpeed',\n];\n\n/** Default root margins */\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\n\n/** Default scroll attribute values */\nconst DEFAULT_SCROLL_OFFSET = '0,0';\nconst DEFAULT_SCROLL_POSITION = 'top,bottom';\n\nexport default class Core {\n    private $scrollContainer!: HTMLElement;\n    private triggerRootMargin!: string;\n    private rafRootMargin!: string;\n    private scrollElements!: ScrollElement[];\n    private triggeredScrollElements!: ScrollElement[];\n    private RAFScrollElements!: ScrollElement[];\n    private scrollElementsToUpdate!: ScrollElement[];\n    private IOTriggerInstance!: IO;\n    private IORafInstance!: IO;\n    private scrollOrientation!: scrollOrientation;\n    private lenisInstance: any;\n\n    constructor({\n        $el,\n        triggerRootMargin,\n        rafRootMargin,\n        scrollOrientation,\n        lenisInstance,\n    }: CoreOptions) {\n        if (!$el) {\n            console.error('Please provide a DOM Element as scrollContainer');\n            return;\n        }\n\n        // Scroll container\n        this.$scrollContainer = $el;\n\n        // Lenis instance\n        this.lenisInstance = lenisInstance;\n\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n\n        // IO Margins\n        this.triggerRootMargin = triggerRootMargin ?? TRIGGER_ROOT_MARGIN;\n        this.rafRootMargin = rafRootMargin ?? RAF_ROOT_MARGIN;\n\n        // ScrollElements arrays\n        this.scrollElements = [];\n        this.triggeredScrollElements = [];\n        this.RAFScrollElements = [];\n        this.scrollElementsToUpdate = [];\n\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize the core.\n     *\n     * @private\n     */\n    private _init() {\n        const $scrollElements =\n            this.$scrollContainer.querySelectorAll('[data-scroll]');\n\n        const $scrollElementsArr = this.toElementArray($scrollElements);\n        this._subscribeScrollElements($scrollElementsArr);\n\n        // Determine IO root (null for window, wrapper element for custom container)\n        const ioRoot = this.lenisInstance.options.wrapper === window\n            ? null\n            : this.lenisInstance.options.wrapper as HTMLElement;\n\n        // Trigger IO\n        this.IOTriggerInstance = new IO({\n            scrollElements: [...this.triggeredScrollElements],\n            root: ioRoot,\n            rootMargin: this.triggerRootMargin,\n            IORaf: false,\n        });\n\n        // Raf IO\n        this.IORafInstance = new IO({\n            scrollElements: [...this.RAFScrollElements],\n            root: ioRoot,\n            rootMargin: this.rafRootMargin,\n            IORaf: true,\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy core.\n     */\n    public destroy() {\n        this.IOTriggerInstance.destroy();\n        this.IORafInstance.destroy();\n        this._unsubscribeAllScrollElements();\n    }\n\n    /**\n     * Callback - Resize callback.\n     */\n    onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.RAFScrollElements) {\n            scrollElement.onResize({\n                currentScroll,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Callback - RAF callback.\n     */\n    onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.scrollElementsToUpdate) {\n            scrollElement.onRender({\n                currentScroll,\n                smooth,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Remove items from lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\n     */\n    removeScrollElements($oldContainer: HTMLElement) {\n        const $scrollElementsToRemove =\n            $oldContainer.querySelectorAll('[data-scroll]');\n\n        if (!$scrollElementsToRemove.length) return;\n\n        const $scrollElementsToRemoveSet = new Set(Array.from($scrollElementsToRemove));\n\n        // 1. Remove from IO\n        for (let index = 0; index < this.triggeredScrollElements.length; index++) {\n            const scrollElement = this.triggeredScrollElements[index];\n            if ($scrollElementsToRemoveSet.has(scrollElement.$el)) {\n                this.IOTriggerInstance.unobserve(scrollElement.$el);\n                this.triggeredScrollElements.splice(index, 1);\n            }\n        }\n\n        for (let index = 0; index < this.RAFScrollElements.length; index++) {\n            const scrollElement = this.RAFScrollElements[index];\n            if ($scrollElementsToRemoveSet.has(scrollElement.$el)) {\n                this.IORafInstance.unobserve(scrollElement.$el);\n                this.RAFScrollElements.splice(index, 1);\n            }\n        }\n\n        // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\n        $scrollElementsToRemove.forEach(($scrollElement) => {\n            const targetScrollElementToUpdate =\n                this.scrollElementsToUpdate.find(\n                    (scrollElement) => scrollElement.$el === $scrollElement\n                );\n            const targetScrollElement = this.scrollElements.find(\n                (scrollElement) => scrollElement.$el === $scrollElement\n            );\n\n            if (targetScrollElementToUpdate) {\n                this._unsubscribeElementUpdate(targetScrollElementToUpdate);\n            }\n            if (targetScrollElement) {\n                this.scrollElements = this.scrollElements.filter(\n                    (scrollElementItem) =>\n                        scrollElementItem.id != targetScrollElement.id\n                );\n            }\n        });\n    }\n\n    /**\n     * Add items to lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\n     */\n    addScrollElements($newContainer: HTMLElement) {\n        // 3. Rebuild ScrollElements\n        const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\n\n        // 4. Get max scrollElement.id\n        const ids: number[] = [];\n        this.scrollElements.forEach((scrollElement) => {\n            ids.push(scrollElement.id);\n        });\n        const maxID = Math.max(...ids, 0);\n        const fromIndex = maxID + 1;\n        const $scrollElementsArr = this.toElementArray($scrollElements);\n        this._subscribeScrollElements(\n            $scrollElementsArr,\n            fromIndex,\n            true\n        );\n    }\n\n    /**\n     * Create a ScrollElement instance for each elements with\n     * `data-scroll` attribute.\n     *\n     * @private\n     *\n     * @param {HTMLElement[]} $scrollElements - List of elements that need\n     *     to be regarded.\n     */\n    _subscribeScrollElements(\n        $scrollElements: HTMLElement[],\n        fromIndex = 0,\n        toObserve = false\n    ) {\n        // For each scroll element create a ScrollElement instance\n        for (let index = 0; index < $scrollElements.length; index++) {\n            const $scrollElement = $scrollElements[index];\n            const needRaf = this._checkRafNeeded($scrollElement);\n\n            const scrollElementInstance = new ScrollElement({\n                $el: $scrollElement,\n                id: fromIndex + index,\n                scrollOrientation: this.scrollOrientation,\n                lenisInstance: this.lenisInstance,\n                subscribeElementUpdateFn:\n                    this._subscribeElementUpdate.bind(this),\n                unsubscribeElementUpdateFn:\n                    this._unsubscribeElementUpdate.bind(this),\n                needRaf,\n            });\n\n            // Push to common array\n            this.scrollElements.push(scrollElementInstance);\n\n            // Push to specific array\n            if (needRaf) {\n                this.RAFScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IORafInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IORafInstance.observe(scrollElementInstance.$el);\n                }\n            } else {\n                this.triggeredScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IOTriggerInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IOTriggerInstance.observe(scrollElementInstance.$el);\n                }\n            }\n        }\n    }\n\n    /**\n     * Clear all ScrollElement arrays.\n     *\n     * @private\n     */\n    _unsubscribeAllScrollElements() {\n        // Destroy all scroll elements to clean up CSS and references\n        for (const scrollElement of this.scrollElements) {\n            scrollElement.destroy();\n        }\n\n        this.scrollElements = [];\n        this.RAFScrollElements = [];\n        this.triggeredScrollElements = [];\n        this.scrollElementsToUpdate = [];\n    }\n\n    /**\n     * Subscribe ScrollElement instance that needs to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - ScrollElement instance inview\n     *     that needs to be updated.\n     */\n    _subscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate.push(scrollElement);\n    }\n\n    /**\n     * Unscribe ScrollElement instance that doesn't need to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - The updated ScrollElement instance\n     *     out of view now.\n     */\n    _unsubscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(\n            (scrollElementToUpdate) =>\n                scrollElementToUpdate.id != scrollElement.id\n        );\n    }\n\n    /**\n     * Convert NodeListOf<Element> to HTMLElement array.\n     *\n     * @private\n     *\n     * @param {NodeListOf<Element>} elements - The NodeList to convert.\n     *\n     * @returns {HTMLElement[]}\n     */\n    private toElementArray(elements: NodeListOf<Element>): HTMLElement[] {\n        return Array.from(elements) as HTMLElement[];\n    }\n\n    /**\n     * Check if a DOM Element need a requestAnimationFrame to be used.\n     *\n     * @private\n     *\n     * @param {HTMLElement} $scrollElement - The element that needs to be checked.\n     *\n     * @returns {boolean}\n     */\n    _checkRafNeeded($scrollElement: HTMLElement) {\n        let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\n\n        // Remove utils\n        const removeAttribute = (attributeToRemove: string) => {\n            attributesThatNeedRaf = attributesThatNeedRaf.filter(\n                (attribute) => attribute !== attributeToRemove\n            );\n        };\n\n        // 1. Check scroll offset values\n        if ($scrollElement.dataset.scrollOffset) {\n            const value = $scrollElement.dataset.scrollOffset\n                .split(',')\n                .map((test) => test.replace('%', '').trim())\n                .join(',');\n            if (value !== DEFAULT_SCROLL_OFFSET) {\n                return true;\n            } else {\n                removeAttribute('scrollOffset');\n            }\n        } else {\n            removeAttribute('scrollOffset');\n        }\n\n        // 2. Check scroll position values\n        if ($scrollElement.dataset.scrollPosition) {\n            const value = $scrollElement.dataset.scrollPosition.trim();\n            if (value !== DEFAULT_SCROLL_POSITION) {\n                return true;\n            } else {\n                removeAttribute('scrollPosition');\n            }\n        } else {\n            removeAttribute('scrollPosition');\n        }\n\n        // 3. Check scroll speed values\n        if (\n            $scrollElement.dataset.scrollSpeed &&\n            !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))\n        ) {\n            return true;\n        } else {\n            removeAttribute('scrollSpeed');\n        }\n\n        // 4. Check others attributes\n        for (const attribute of attributesThatNeedRaf) {\n            if (attribute in $scrollElement.dataset) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","import { version } from './package.json'\nimport Lenis from 'lenis';\nimport Core from './core/Core';\nimport type {\n    ILenisScrollToOptions,\n    ILenisScrollValues,\n    ILocomotiveScrollOptions,\n    lenisTargetScrollTo,\n} from './types';\nimport type { LenisOptions } from 'lenis';\n\n/**\n * Locomotive Scroll\n *\n * Detection of elements in viewport & smooth scrolling with parallax.\n *\n * Inspired by\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\n * and built around\n * {@link https://github.com/darkroomengineering/lenis lenis.js}.\n */\n\nexport default class LocomotiveScroll {\n    public rafPlaying: boolean;\n    public lenisInstance: Lenis | null = null;\n\n    private coreInstance: Core | null = null;\n\n    private lenisOptions?: LenisOptions;\n    private triggerRootMargin?: string;\n    private rafRootMargin?: string;\n    private rafInstance?: number;\n    private autoStart?: boolean;\n    private isTouchDevice: boolean;\n    private scrollCallback?(scrollValues: ILenisScrollValues): void;\n    private initCustomTicker?: (render: () => void) => void;\n    private destroyCustomTicker?: (render: () => void) => void;\n    private _onRenderBind: () => void;\n    private _onResizeBind: () => void;\n    private _onScrollToBind: (event: MouseEvent) => void;\n    private _originalOnContentResize?: () => void;\n    private _originalOnWrapperResize?: () => void;\n\n    constructor({\n        lenisOptions = {},\n        triggerRootMargin,\n        rafRootMargin,\n        autoStart = true,\n        scrollCallback = () => {},\n        initCustomTicker,\n        destroyCustomTicker,\n    }: ILocomotiveScrollOptions = {}) {\n\n        // Set version\n        window.locomotiveScrollVersion = version;\n\n        // Get arguments\n        Object.assign(this, {\n            lenisOptions,\n            triggerRootMargin,\n            rafRootMargin,\n            autoStart,\n            scrollCallback,\n            initCustomTicker,\n            destroyCustomTicker,\n        });\n\n\n        // Binding\n        this._onRenderBind = this._onRender.bind(this);\n        this._onScrollToBind = this._onScrollTo.bind(this);\n        this._onResizeBind = this._onResize.bind(this);\n\n        // Data\n        this.rafPlaying = false;\n\n        // Detect if device has touch capability\n        this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize instance.\n     *\n     * @private\n     */\n    private _init(): void {\n        \n        // Create Lenis instance\n        this.lenisInstance = new Lenis({\n            ...this.lenisOptions\n        });\n\n        // Subscribe to scroll callback if provided\n        if (this.scrollCallback) {\n            this.lenisInstance.on('scroll', this.scrollCallback);\n        }\n\n        // Add scroll direction attribute on body\n        document.documentElement.setAttribute(\n            'data-scroll-orientation',\n            this.lenisInstance.options.orientation\n        );\n\n        requestAnimationFrame(() => {\n            // Create Core Instance\n            // lenisInstance is guaranteed to exist at this point (created above)\n            this.coreInstance = new Core({\n                $el: this.lenisInstance!.rootElement,\n                triggerRootMargin: this.triggerRootMargin,\n                rafRootMargin: this.rafRootMargin,\n                scrollOrientation: this.lenisInstance!.options.orientation,\n                lenisInstance: this.lenisInstance!,\n            });\n\n            // Bind Events\n            this._bindEvents();\n\n            // RAF warning\n            if (this.initCustomTicker && !this.destroyCustomTicker) {\n                console.warn(\n                    'initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            } else if (!this.initCustomTicker && this.destroyCustomTicker) {\n                console.warn(\n                    'destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            }\n\n            // Start RAF\n            this.autoStart && this.start();\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy instance.\n     */\n    public destroy(): void {\n        // Stop raf\n        this.stop();\n        // Unbind Events\n        this._unbindEvents();\n        // Destroy Lenis\n        this.lenisInstance?.destroy();\n\n        // Destroy Core after RAF to ensure any pending Intersection Observer callbacks complete\n        // This prevents race conditions when destroy() is called while IO callbacks are queued\n        requestAnimationFrame(() => {\n            this.coreInstance?.destroy();\n        });\n    }\n\n    /**\n     * Events - Subscribe events to listen.\n     */\n    private _bindEvents() {\n        this._bindScrollToEvents();\n\n        // Hook into Lenis dimensions resize callbacks\n        // onContentResize: called when content size changes (images load, dynamic content)\n        // onWrapperResize: called when wrapper size changes (window resize, layout changes)\n        if (this.lenisInstance) {\n            this._originalOnContentResize = this.lenisInstance.dimensions.onContentResize.bind(\n                this.lenisInstance.dimensions\n            );\n            this._originalOnWrapperResize = this.lenisInstance.dimensions.onWrapperResize.bind(\n                this.lenisInstance.dimensions\n            );\n\n            this.lenisInstance.dimensions.onContentResize = () => {\n                this._originalOnContentResize?.();\n                this._onResizeBind();\n            };\n\n            this.lenisInstance.dimensions.onWrapperResize = () => {\n                this._originalOnWrapperResize?.();\n                this._onResizeBind();\n            };\n        }\n    }\n\n    /**\n     * Events - Unsubscribe listened events.\n     */\n    private _unbindEvents() {\n        this._unbindScrollToEvents();\n\n        // Restore original Lenis dimensions resize callbacks\n        if (this.lenisInstance) {\n            if (this._originalOnContentResize) {\n                this.lenisInstance.dimensions.onContentResize = this._originalOnContentResize;\n            }\n            if (this._originalOnWrapperResize) {\n                this.lenisInstance.dimensions.onWrapperResize = this._originalOnWrapperResize;\n            }\n        }\n    }\n\n    /**\n     * Events - Subscribe scrollTo events to listen.\n     */\n    private _bindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance?.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el): void => {\n                ($el as HTMLElement).addEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Events - Unsubscribe scrollTo listened events.\n     */\n    private _unbindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance?.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el) => {\n                ($el as HTMLElement).removeEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Callback - Resize callback.\n     *\n     * Called synchronously after Lenis updates its dimensions via onContentResize/onWrapperResize.\n     * All dimension values are already up-to-date when this executes.\n     */\n    private _onResize() {\n        this.coreInstance?.onResize({\n            currentScroll: this.lenisInstance?.scroll ?? 0,\n            smooth: !this.isTouchDevice,\n        });\n    }\n\n    /**\n     * Callback - Render callback.\n     */\n    private _onRender() {\n        this.lenisInstance?.raf(Date.now());\n\n        this.coreInstance?.onRender({\n            currentScroll: this.lenisInstance?.scroll ?? 0,\n            smooth: !this.isTouchDevice,\n        });\n    }\n\n    /**\n     * Callback - Scroll To callback.\n     */\n    private _onScrollTo(event: MouseEvent) {\n        event.preventDefault();\n        const $target = (event.currentTarget as HTMLElement) ?? null;\n        if (!$target) return;\n        const target =\n            $target.getAttribute('data-scroll-to-href') ||\n            $target.getAttribute('href');\n        const offset = $target.getAttribute('data-scroll-to-offset') || 0;\n        const duration =\n            $target.getAttribute('data-scroll-to-duration') ||\n            this.lenisInstance?.options.duration\n        target &&\n            this.scrollTo(target, {\n                offset: typeof offset === 'string' ? parseInt(offset) : offset,\n                duration:\n                    typeof duration === 'string'\n                        ? parseInt(duration)\n                        : duration,\n            });\n    }\n\n    /**\n     * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public start(): void {\n        if (this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis start method\n        this.lenisInstance?.start();\n\n        this.rafPlaying = true;\n        this.initCustomTicker\n            ? this.initCustomTicker(this._onRenderBind)\n            : this._raf();\n    }\n\n    /**\n     * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public stop(): void {\n        if (!this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis stop method\n        this.lenisInstance?.stop();\n\n        this.rafPlaying = false;\n        this.destroyCustomTicker\n            ? this.destroyCustomTicker(this._onRenderBind)\n            : this.rafInstance && cancelAnimationFrame(this.rafInstance);\n    }\n\n    /**\n     * Remove old scroll elements items and rebuild ScrollElements instances.\n     */\n    public removeScrollElements($oldContainer: HTMLElement): void {\n        if (!$oldContainer) {\n            console.error('Please provide a DOM Element as $oldContainer');\n            return;\n        }\n\n        this._unbindScrollToEvents($oldContainer);\n        this.coreInstance?.removeScrollElements($oldContainer);\n    }\n\n    /**\n     * Add new scroll elements items and rebuild ScrollElements instances.\n     */\n    public addScrollElements($newContainer: HTMLElement): void {\n        if (!$newContainer) {\n            console.error('Please provide a DOM Element as $newContainer');\n            return;\n        }\n\n        this.coreInstance?.addScrollElements($newContainer);\n        requestAnimationFrame(() => {\n            this._bindScrollToEvents($newContainer);\n        });\n    }\n\n    /**\n     * Trigger resize callback.\n     */\n    public resize(): void {\n        this._onResizeBind();\n    }\n\n    /**\n     * Trigger scroll to callback.\n     */\n    public scrollTo(\n        target: lenisTargetScrollTo,\n        options?: ILenisScrollToOptions\n    ): void {\n        this.lenisInstance?.scrollTo(target, {\n            offset: options?.offset,\n            lerp: options?.lerp,\n            duration: options?.duration,\n            immediate: options?.immediate,\n            lock: options?.lock,\n            force: options?.force,\n            easing: options?.easing,\n            onComplete: options?.onComplete,\n        });\n    }\n\n    /**\n     * RequestAnimationFrame that active Lenis smooth and scroll progress.\n     *\n     * @private\n     *\n     */\n    private _raf() {\n        this._onRenderBind();\n        this.rafInstance = requestAnimationFrame(() => this._raf());\n    }\n}\n\nexport * from './types';\n"],"names":["clamp","min","input","max","Math","Animate","isRunning","value","from","to","currentTime","lerp","duration","easing","onUpdate","advance","deltaTime","this","completed","linearProgress","easedProgress","x","y","lambda","t","exp","damp","round","stop","fromTo","_ref","lerp2","onStart","Dimensions","constructor","wrapper","content","autoResize","debounce","debounceValue","arguments","length","undefined","debouncedResize","callback","delay","timer","_len","args","Array","_key","context","clearTimeout","setTimeout","apply","resize","Window","window","addEventListener","wrapperResizeObserver","ResizeObserver","observe","contentResizeObserver","width","height","scrollHeight","scrollWidth","destroy","disconnect","removeEventListener","onWrapperResize","onContentResize","innerWidth","innerHeight","clientWidth","clientHeight","limit","Emitter","events","emit","event","callbacks","_len2","_key2","i","on","cb","push","filter","off","LINE_HEIGHT","listenerOptions","passive","VirtualScroll","element","options","wheelMultiplier","touchMultiplier","onWindowResize","onWheel","onTouchStart","onTouchMove","onTouchEnd","touchStart","lastDelta","emitter","clientX","clientY","targetTouches","deltaX","deltaY","deltaMode","defaultEasing","pow","Lenis","_isScrolling","_isStopped","_isLocked","_preventNextNativeScrollEvent","_resetVelocityTimeout","_rafId","isTouching","time","userData","lastVelocity","velocity","direction","targetScroll","animatedScroll","animate","dimensions","virtualScroll","document","documentElement","eventsTarget","smoothWheel","syncTouch","syncTouchLerp","touchInertiaExponent","infinite","orientation","gestureOrientation","prevent","overscroll","autoRaf","anchors","autoToggle","allowNestedScroll","__experimental__naiveDimensions","naiveDimensions","stopInertiaOnNavigate","lenisVersion","updateClassName","actualScroll","onNativeScroll","onScrollEnd","capture","onClick","onPointerDown","onVirtualScroll","checkOverflow","rootElement","onTransitionEnd","requestAnimationFrame","raf","cleanUpClassName","cancelAnimationFrame","e","CustomEvent","isScrolling","stopPropagation","dispatchScrollendEvent","dispatchEvent","bubbles","detail","lenisScrollEnd","overflow","property","isHorizontal","getComputedStyle","includes","internalStop","internalStart","propertyName","setScroll","scroll","scrollTo","left","behavior","top","anchorElements","composedPath","node","HTMLAnchorElement","getAttribute","anchor","find","href","target","split","host","location","reset","button","data","ctrlKey","lenisStopPropagation","isTouch","type","isWheel","isClickOrTap","isStopped","isLocked","isUnknownGesture","slice","indexOf","HTMLElement","hasAttribute","checkNestedScroll","cancelable","preventDefault","delta","abs","isSyncTouch","hasTouchInertia","sign","programmatic","lastScroll","start","style","removeProperty","setProperty","offset","immediate","lock","onComplete","force","querySelector","console","warn","nodeType","wrapperRect","getBoundingClientRect","rect","distance","preventNextNativeScrollEvent","_ref2","Date","now","cache","_lenis","hasOverflowX","hasOverflowY","isScrollableX","isScrollableY","computedStyle","overflowXString","overflowX","overflowYString","overflowY","maxScroll","hasOverflow","isScrollable","scrollLeft","scrollTop","scrollX","scrollY","n","d","modulo","progress","isSmooth","className","trim","replace","scrollElements","rootMargin","s","root","IORaf","observer","_init","IntersectionObserver","forEach","$el","isIntersecting","isAlreadyIntersected","_setInview","_setOutOfView","unobserve","setInteractivityOn","setInview","setInteractivityOff","setOutOfView","attributes","scrollRepeat","reduce","r","l","id","subscribeElementUpdateFn","unsubscribeElementUpdateFn","needRaf","scrollOrientation","lenisInstance","o","a","c","h","intersection","metrics","currentScroll","translateValue","lastProgress","isInview","isInteractive","isInFold","isFirstResize","getWindowSize","getMetricsStart","getMetricsSize","startPositionHandlers","middle","end","fold","endPositionHandlers","scrollClass","dataset","scrollOffset","scrollPosition","scrollCssProgress","scrollEventProgress","scrollSpeed","parseFloat","scrollCall","scrollIgnoreFold","scrollEnableTouchSpeed","offsetStart","offsetEnd","bcr","_resize","onResize","_ref3","onRender","_ref4","smooth","_computeProgress","isNaN","transform","classList","add","_getScrollCallFrom","_dispatchCall","remove","_computeMetrics","_computeIntersection","u","m","v","f","g","parseInt","p","I","b","_setCssProgress","_setCustomEventProgress","toString","way","_ref5","triggerRootMargin","rafRootMargin","$scrollContainer","triggeredScrollElements","RAFScrollElements","scrollElementsToUpdate","IOTriggerInstance","IORafInstance","error","querySelectorAll","toElementArray","_subscribeScrollElements","_unsubscribeAllScrollElements","_ref6","_ref7","removeScrollElements","Set","has","splice","_unsubscribeElementUpdate","addScrollElements","_checkRafNeeded","_subscribeElementUpdate","bind","map","join","lenisOptions","autoStart","scrollCallback","initCustomTicker","destroyCustomTicker","rafPlaying","coreInstance","rafInstance","isTouchDevice","_onRenderBind","_onResizeBind","_onScrollToBind","_originalOnContentResize","_originalOnWrapperResize","locomotiveScrollVersion","Object","assign","_onRender","_onScrollTo","_onResize","navigator","maxTouchPoints","setAttribute","_bindEvents","_unbindEvents","_bindScrollToEvents","call","_unbindScrollToEvents","currentTarget","_raf"],"sourceRoot":""}